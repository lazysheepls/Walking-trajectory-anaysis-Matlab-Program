%% Wk 5 Rewrite and modularization
clearvars -except shiftX shiftY shiftZ;
close all;
%% Section 0: Read file
% Set 1: wk9:Gyro has wired shift problem
% 2015-05-03_01-20-07.csv
% 2015-05-03_01-20-43.csv
% Set 1: wk10/set1 Calib Testing
% 2015-05-12_13-57-04.csv
% 2015-05-11_15-50-13.csv
filename = '/wk10/2015-05-11_15-50-13.csv'; 
filelocation = ['/Users/lazysheep/Study/Thesis/sensor logging Raw files',filename];
T = readtable(filelocation);
% CalibFactor: 1: Calib gyro(place on flat surface)  
%              2: Calib Compass: rotate phone around
%              3: Calib Fin: Analysis data
CalibFactor = 2;
% GPS API Key activation Factor: 1:Connect with API for the first time 2:No need to activate
StaticMapAPIkeyFactor = 2;
%% Section 1: Rename all the input data from "SensorLog" App
%  Process file by "B1F1_HandleInputfile" function
[time,accelX,accelY,accelZ,gyroX,gyroY,gyroZ,magnetX,magnetY,magnetZ,XcodeTrueHeading,XcodeMagneticHeading,XcodeHeadingAccuracy,Lat,Long,GPSspeed,GPScourse]=B1F1_HandleInputfile(T);
%  Clear workspace
clearvars T;
%% Section 2: Plot raw data
B1F2_PlotRawData(time,accelX,accelY,accelZ,gyroX,gyroY,gyroZ,magnetX,magnetY,magnetZ,XcodeTrueHeading,XcodeMagneticHeading);

%% Section 3: Accelerometer raw data noise filtering
[accelXft,accelYft,accelZft] = B1F3_FilterNoiseAccelData(time,accelX,accelY,accelZ);

%% Section 4: Gyroscope raw data noise filtering and elminate bias&shift
if CalibFactor==1
shiftX=0;shiftY=0;shiftZ=0;
    [gyroXft,gyroYft,gyroZft,shiftX,shiftY,shiftZ] = B1F4_FilterNoiseGyroData(time,gyroX,gyroY,gyroZ,shiftX,shiftY,shiftZ,CalibFactor);
else
    [gyroXft,gyroYft,gyroZft,shiftX,shiftY,shiftZ] = B1F4_FilterNoiseGyroData(time,gyroX,gyroY,gyroZ,shiftX,shiftY,shiftZ,CalibFactor);
end

%% Section 5: Convert Roll Pitch & Yaw angle based on gyroscope ONLY

[RollGyro,PitchGyro,YawGyro] = B1F5_GyroConvertRollPitchYaw(time,gyroXft,gyroYft,gyroZft);

%  The following program will not run during the gyro calib process
%  process(CalibFactor=1)
if CalibFactor==1
    return;     % program terminated
end

%% Section 6: Convert Roll & Pitch angle based on acceletometer ONLY
[RollAccel,PitchAccel] = B1F6_AccelConvertRollPitch(time,accelXft,accelYft,accelZft);
%% Section 7: Magnetometer Calibration
if CalibFactor ==2
e_center=0;
e_radii=0;
e_eigenvecs=0;
e_algebraic=0;
[magnetXCab,magnetYCab,magnetZCab,e_center,e_radii,e_eigenvecs,e_algebraic] = B1F7_MagnetCalibration(CalibFactor,magnetX,magnetY,magnetZ,e_center,e_radii,e_eigenvecs,e_algebraic);
save('MagnetTempCalib','e_center','e_radii','e_eigenvecs','e_algebraic');
elseif CalibFactor ==3
load('MagnetTempCalib');
[magnetXCab,magnetYCab,magnetZCab,e_center,e_radii,e_eigenvecs,e_algebraic] = B1F7_MagnetCalibration(CalibFactor,magnetX,magnetY,magnetZ,e_center,e_radii,e_eigenvecs,e_algebraic);
end

%% Section 8: Convert to heading angles based on megnatometer ONLY
[magnetHeading] = B1F8_MagnetConvertHeading(time,magnetXCab,magnetYCab,magnetZCab,PitchAccel,RollAccel,XcodeMagneticHeading,XcodeTrueHeading);
% Now We could either use magnetHeading/ XcodeTruHeading(XcodeTureHeading is still more accurate)

%% Section 8+: Before data fusion
%  The following program will not run during the magnet calibration
%  process(CalibFactor=2)
if CalibFactor==2
    return;     % program terminated
end

%  For the first time only: Google map static API need to be connected with
%  API key. After that, no key is needed.(StaticMapAPIkeyFactor=1)
if StaticMapAPIkeyFactor==1
%   API key: AIzaSyBCA_bJ4J52eNG1pOcih3JxMXnxkIZsrI4
    plot_google_map('APIKey','AIzaSyBCA_bJ4J52eNG1pOcih3JxMXnxkIZsrI4')
end

%% Section 9: Find Steps from accel Roll angles
[stepPks,stepLocs,stepGaps,stepNo,stepAvgGaptime] = B1F9_FindStepsFromAccelRoll(time,RollAccel);

%% Section 10: Gyro Yaw angle recalibrated before datafusion 
%calibration to fit with magnet and GPS course angle coordiante
[YawGyroCalib,InitHeading] = B1F10_YawGyroRecalib(XcodeTrueHeading,GPScourse,YawGyro,time);

%% Section 11: Speed calculation and selection before data fusion
%  Outcome 3 type of speed: 1. GPS speed mode
%                           2. Average speed per step mode(NOTE: NOT Pedometer)
%                           3. Accel speed mode(**NOTE:Not available**Check accelGetSpeedTest.m**)

stepSize = 0.65;  % 65cm fixed for now
[GPSspeed,stepSpeed] = B1F11_SpeedModeSelection(GPSspeed,accelX,accelY,time,stepLocs,stepGaps,stepSize);

%% Section 12: DataFusion

%% Section 13: Pedometer algorithm: Analysis data in step based mode